#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_X_SIZE_MAX 32
#define WORKGROUP_Y_SIZE_MAX 1
#define WORKGROUP_Z_SIZE_MAX 1

#define MAX_PLANES 4

#define UINT_MAX 4294967295
#define FLT_MAX  3.402823466e+38F

layout(local_size_x = WORKGROUP_X_SIZE_MAX, local_size_y = WORKGROUP_Y_SIZE_MAX, local_size_z = WORKGROUP_Z_SIZE_MAX) in;

layout(binding = 0) uniform sampler2D sceneMap;
layout(binding = 1) uniform sampler2D depthMap;


layout(set = 0, binding = 2) buffer reflectDepth
{
	uint ssRdepth[];
};

layout(set = 0, binding = 3) uniform cameraBuffer
{
	mat4 viewMat;
	mat4 projMat;
	mat4 viewProjMat;
	mat4 InvViewProjMat;

	vec4 cameraWorldPos;
	vec4 viewPortSize;
};


struct PlaneInfo
{
	mat4 rotMat;
	vec4 centerPoint;
	vec4 size;
};

layout(set = 0, binding = 4) uniform planeInfoBuffer
{	
	PlaneInfo planeInfo[MAX_PLANES];
	uint numPlanes;
	uint pad00;
	uint pad01;
	uint pad02;
};


float depthLinear(float depth)
{	
	float f = 1000.0;
	float n = 0.1;
	return (2.0 * n) / (f + n - depth * (f - n));
}

float getDistance(vec3 planeNormal, vec3 planeCenter, vec3 worldPos)
{
	//plane to point
	float d = -dot(planeNormal, planeCenter);
	return (dot(planeNormal, worldPos) + d) / length(planeNormal);
}


bool intersectPlane(in uint index, in vec3 worldPos, in vec2 fragUV, out vec4 reflectedPos, out vec2 relfectedUV) 
{ 
	PlaneInfo thisPlane = planeInfo[index];

	// assuming vectors are all normalized
	vec3 normalVec;	
	normalVec = thisPlane.rotMat[2].xyz;
	
	vec3 centerPoint = thisPlane.centerPoint.xyz;

	vec3 projectedWorldPos = dot(normalVec, worldPos - centerPoint) * normalVec;
	vec3 target = worldPos - 2.0 * projectedWorldPos;

	//plane to point	
	float dist = getDistance(normalVec, centerPoint, target);

	
	//if target is on the upper-side of plane, false 
	if(dist >= 0.0)
	{
		return false;
	}

	vec3 rO = cameraWorldPos.xyz;
	vec3 rD = normalize(target - rO);

	vec3 rD_VS = mat3(viewMat) * rD;

	
	if(rD_VS.z > 0.0)
	{
		return false;
	}
	

    float denom = dot(normalVec, rD); 

    if (denom < 0.0)
	{ 
        vec3 p0l0 = centerPoint - rO; 
        float t = dot(normalVec, p0l0) / denom; 

		if(t <= 0.0)
		{
			return false;
		}

		vec3 hitPoint = rO + rD*t;	

		vec3 gap = hitPoint - centerPoint;
		
		float xGap = dot(gap, thisPlane.rotMat[0].xyz);
		float yGap = dot(gap, thisPlane.rotMat[1].xyz);

		float width = thisPlane.size.x * 0.5;
		float height = thisPlane.size.y * 0.5;

		if( (abs(xGap) <= width) && (abs(yGap) <= height))
		{
			reflectedPos = viewProjMat * vec4(hitPoint, 1.0);
			reflectedPos /= reflectedPos.w;

			reflectedPos.xy = (reflectedPos.xy + vec2(1.0)) * 0.5;

			float depth = texture(depthMap, reflectedPos.xy).x;	

			if(depth <= reflectedPos.z)
				return false;
			
			if( reflectedPos.x < 0.0 || reflectedPos.y < 0.0  || reflectedPos.x > 1.0 || reflectedPos.y > 1.0 )
			{
				return false;
			}
			else
			{
				relfectedUV = vec2(xGap / width, yGap / height) * 0.5 + vec2(0.5);
				relfectedUV *= thisPlane.size.zw;
				return true; 
			}			
		}	
		else
		{
			return false;
		}
    } 
	else
	{
		return false; 
	}
} 

vec4 getWorldPosition(vec2 UV, float depth)
{
	vec4 worldPos = InvViewProjMat * vec4(UV * 2.0 - 1.0, depth, 1.0);
	worldPos /= worldPos.w;

	return worldPos;
}

void main() {
	
	vec2 dividedViewSize = vec2(viewPortSize.x, viewPortSize.y);

	uint screenWidth = uint( dividedViewSize.x );
	uint screenHeight = uint( dividedViewSize.y );
	
	uint index = gl_GlobalInvocationID.x;
	

	if(index >= screenWidth * screenHeight)
		return;

	uint y = index / screenWidth;
	uint x = index - screenWidth * y;

	vec2 fragUV = vec2(float(x) / (dividedViewSize.x), float(y) / (dividedViewSize.y) );
	float depth = texture(depthMap, fragUV).x;	

	if(depth >= 1.0)
		return;

	vec4 worldPos = getWorldPosition(fragUV, depth);
	vec3 viewVec = normalize( cameraWorldPos.xyz - worldPos.xyz);
	
	vec4 reflectedPos = vec4(0.0);

	ivec2 reflectedUV;
	vec2 trueReflectedUV;

	uint relfectedPlanarIndex;
	for(uint i = 0; i < numPlanes; i++)
	{	
		if(!intersectPlane( i, worldPos.xyz, fragUV, reflectedPos, trueReflectedUV ))
		{
			return;			
		}

		relfectedPlanarIndex = i;
	}

	reflectedUV =  ivec2( reflectedPos.x * dividedViewSize.x, reflectedPos.y * dividedViewSize.y);

	uint reflectingIndex = reflectedUV.x + screenWidth * reflectedUV.y;

	uint yGap = y - reflectedUV.y;
	uint xGap = x - reflectedUV.x;

	vec2 offset2 = vec2( (fragUV.x - reflectedPos.x), ( fragUV.y - reflectedPos.y));

	offset2.x *= dividedViewSize.x;
	offset2.y *= dividedViewSize.y;

	uint CoordSys = 0;

	uint YInt = 0;
	int YFrac = 0;
	int XInt = 0;
	int XFrac = 0;

	//define CoordSystem
	if(abs(offset2.y) < abs(offset2.x) )
	{
		if(offset2.x < 0.0) // 3
		{
			YInt = uint(-offset2.x);
			YFrac = int(fract(offset2.x)*8.0);
			
			XInt = int(offset2.y);
			XFrac = int(fract(offset2.y)*8.0);

			CoordSys = 3;
		}
		else // 1
		{
			YInt = uint(offset2.x);
			YFrac = int(fract(offset2.x)*8.0);
			
			XInt = int(offset2.y);
			XFrac = int(fract(offset2.y)*8.0);

			CoordSys = 1;
		}
	}
	else	
	{

		if(offset2.y < 0.0) // 2
		{
			YInt = uint(-offset2.y);
			YFrac = int(fract(offset2.y)*8.0);
			
			XInt = int(offset2.x);
			XFrac = int(fract(offset2.x)*8.0);

			CoordSys = 2;
		}
		else // 0
		{
			YInt = uint(offset2.y);
			YFrac = int(fract(offset2.y)*8.0);
			
			XInt = int(offset2.x);
			XFrac = int(fract(offset2.x)*8.0);

			CoordSys = 0;
		}
	}	

	//pack info
	uint intermediateBufferValue = ( (YInt & 0x00000fff ) << 20) | ( (YFrac & 0x00000007) << 17) | ( (XInt & 0x00000fff) << 5) | ( (XFrac & 0x00000007 )<< 2) | CoordSys;
	
	atomicMin(ssRdepth[reflectingIndex], intermediateBufferValue);
}
 